#!/bin/bash
if  -d "$HOME/.config/gri" ; then
  source "$HOME/.config/gri/gri.conf"
else
  mkdir -p "$HOME/.config/gri"
  echo "GRI_CONFIG_GIT_SERVER=github.com\nGRI_CONFIG_OUTPUT=\$HOME" > "$HOME/.config/gri/gri.conf"
  touch "$HOME/.config/gri/installed"
fi

#
# ARG_POSITIONAL_SINGLE([user],[user or organization name])
# ARG_POSITIONAL_SINGLE([app],[app name])
# ARG_POSITIONAL_SINGLE([tag],[tag information])
# ARG_POSITIONAL_SINGLE([output],[output directory],[$([ -n "$GRI_CONFIG_OUTPUT" ]&&echo $GRI_CONFIG_OUTPUT||echo $HOME)])
# ARG_OPTIONAL_SINGLE([arch],[a],[target architecture],[])
# ARG_OPTIONAL_SINGLE([git-server],[g],[git server domain],[$([ -n "$GRI_CONFIG_GIT_SERVER" ]&&echo $GRI_CONFIG_GIT_SERVER||echo 'github.com')])
# ARG_OPTIONAL_BOOLEAN([secure],[],[use ssl connection to git server],[on])
# ARG_OPTIONAL_BOOLEAN([extract],[],[extract],[on])
# ARG_OPTIONAL_BOOLEAN([exec],[],[add execution right],[on])
# ARG_OPTIONAL_BOOLEAN([source],[],[download source])
# ARG_HELP([easily grab release from github])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='agh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_output="$([ -n "$GRI_CONFIG_OUTPUT" ]&&echo $GRI_CONFIG_OUTPUT||echo $HOME)"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_arch=
_arg_git_server="$([ -n "$GRI_CONFIG_GIT_SERVER" ]&&echo $GRI_CONFIG_GIT_SERVER||echo 'github.com')"
_arg_secure="on"
_arg_extract="on"
_arg_exec="on"
_arg_source="off"


print_help()
{
	printf '%s\n' "easily grab release from github"
	printf 'Usage: %s [-a|--arch <arg>] [-g|--git-server <arg>] [--(no-)secure] [--(no-)extract] [--(no-)exec] [--(no-)source] [-h|--help] <user> <app> <tag> [<output>]\n' "$0"
	printf '\t%s\n' "<user>: user or organization name"
	printf '\t%s\n' "<app>: app name"
	printf '\t%s\n' "<tag>: tag information"
	printf '\t%s\n' "<output>: output directory (default: '$([ -n "$GRI_CONFIG_OUTPUT" ]&&echo $GRI_CONFIG_OUTPUT||echo $HOME)')"
	printf '\t%s\n' "-a, --arch: target architecture (no default)"
	printf '\t%s\n' "-g, --git-server: git server domain (default: '$([ -n "$GRI_CONFIG_GIT_SERVER" ]&&echo $GRI_CONFIG_GIT_SERVER||echo 'github.com')')"
	printf '\t%s\n' "--secure, --no-secure: use ssl connection to git server (on by default)"
	printf '\t%s\n' "--extract, --no-extract: extract (on by default)"
	printf '\t%s\n' "--exec, --no-exec: add execution right (on by default)"
	printf '\t%s\n' "--source, --no-source: download source (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-a|--arch)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_arch="$2"
				shift
				;;
			--arch=*)
				_arg_arch="${_key##--arch=}"
				;;
			-a*)
				_arg_arch="${_key##-a}"
				;;
			-g|--git-server)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_git_server="$2"
				shift
				;;
			--git-server=*)
				_arg_git_server="${_key##--git-server=}"
				;;
			-g*)
				_arg_git_server="${_key##-g}"
				;;
			--no-secure|--secure)
				_arg_secure="on"
				test "${1:0:5}" = "--no-" && _arg_secure="off"
				;;
			--no-extract|--extract)
				_arg_extract="on"
				test "${1:0:5}" = "--no-" && _arg_extract="off"
				;;
			--no-exec|--exec)
				_arg_exec="on"
				test "${1:0:5}" = "--no-" && _arg_exec="off"
				;;
			--no-source|--source)
				_arg_source="on"
				test "${1:0:5}" = "--no-" && _arg_source="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'user', 'app' and 'tag'"
	test "${_positionals_count}" -ge 3 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 3 and 4 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 4 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 3 and 4 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_user _arg_app _arg_tag _arg_output "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


grilog="$_arg_user $_arg_app $_arg_tag $_arg_output --git-server $_arg_git_server"

if [ -n "$_arg_arch" ]; then
  grilog="$grilog --arch $_arg_arch"
  _arg_arch="_$_arg_arch"
fi

GRI_PROTOCOL="http"
if [ "$_arg_secure" != "off" ]; then
  GRI_PROTOCOL="${GRI_PROTOCOL}s"
fi

if [ "$_arg_source" == "on" ]; then
  GRI_BASE_URL="${GRI_PROTOCOL}://${_arg_git_server}/${_arg_user}/${_arg_app}/archive/refs/tags/v${_arg_tag}.tar.gz"
  _arg_exec="off"
  grilog="$grilog --source"
else
  GRI_BASE_URL="${GRI_PROTOCOL}://${_arg_git_server}/${_arg_user}/${_arg_app}/releases/download/v${_arg_tag}/${_arg_app}_${_arg_tag}${_arg_arch}.tar.gz"
fi

GRI_TMP_FILE=$(mktemp)

if [ ! -d "${_arg_output}/${_arg_app}_${_arg_tag}" ]; then
  mkdir -p "${_arg_output}/${_arg_app}_${_arg_tag}"
fi

curl -LJ --output $GRI_TMP_FILE $GRI_BASE_URL

if [ "$_arg_extract" == "off" ]; then
  cp "$GRI_TMP_FILE" "${_arg_output}/${_arg_app}_${_arg_tag}${_arg_arch}.tar.gz"
else
  tar -xzf "$GRI_TMP_FILE" -C "${_arg_output}/${_arg_app}_${_arg_tag}"

  if [ "$_arg_exec" != "off" ]; then
    chmod +x "${_arg_output}/${_arg_app}_${_arg_tag}" -R
  fi
fi

rm $GRI_TMP_FILE

echo "$grilog" >> "$HOME/.config/gri/installed"

# ] <-- needed because of Argbash
